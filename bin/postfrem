#!/usr/bin/perl

# Only for Development
use FindBin qw($Bin);
use lib "$Bin/../lib";

# Don't edit the line below, it must look exactly like this.
# Everything above this line will be replaced #

# Perl includes #
use Config;
use strict;
use Getopt::Long;
# External modules #
use Math::Random;
# PsN includes #
use PsN;
use common_options;
use ui;
use logging;
use Cwd;
use File::Copy qw/cp mv/;
use File::Glob;
use File::Path 'rmtree';
use File::Spec;
use tool;
use tool::frem;
use tool::sir;
use output;
use linear_algebra;
use array qw(quantile unique);
use math qw(round);
use MooseX::Params::Validate;
use rplots;
use Carp;
# More PsN dependencies included with require further down

my $minimum = 100;

my %categorytext=();
$categorytext{'SEX'}={1=>'male',2=>'female'}; #hamren
my %units = ('AGE'=> 'years','WGT'=>'kg','WT'=>'kg','LBW'=>'kg','CRCO'=> 'ml/min','CLCR'=> 'ml/min','NEUY'=> 'mg'); #hamren

#FIXME optional input units and categorytexts

my $cmd_line = $0 . " " . join( " ", @ARGV );

my %options;

my %required_options = ();
my %optional_options = (
    'offset_rawres:i' => undef,
    'in_filter:s' => undef,
    'output_format:s' => undef,
    'final_model:s' => undef,
    'frem_directory:s' => undef,
    'sir_directory:s' => undef,
    'force_posdef_covmatrix!' => undef,
    'force_m1_propagation!' => undef,
    'force_posdef_samples!' => undef,
    'print_iter:i' => undef,
);

my $res = GetOptions( \%options,
                      @common_options::get_opt_strings,
                      keys(%required_options),
                      keys(%optional_options) );

exit unless $res;

my %help_text;
$help_text{Pre_help_message} = <<'EOF';
    Postprocessing for frem
EOF

$help_text{Description} = <<'EOF';
    model plus raw_results from sir
EOF

$help_text{Options} = <<'EOF';

    The following options are valid:
EOF

$help_text{Examples} = <<'EOF';
    postfrem -model=model_4.mod rawres_input=raw_results_model_4.mod -in_filter=resamples.gt.0
EOF

$help_text{-offset_rawres} = <<'EOF';
    -offset_rawres=N

    Default is 1, i.e. first line is minimum. Do not set to 0.
EOF

$help_text{-output_format} = <<'EOF';
    -output_format=format

    Default is pdf. Supported formats are pdf, png, svg and jpg.svg requires
    library(svglite).
EOF

$help_text{-in_filter} = <<'EOF';
    -in_filter=comma-separated list of conditions

    Default not used.
    If full sir run then set to resamples.gt.0, otherwise skip.
EOF

$help_text{-force_posdef_covmatrix} = <<'EOF';
    -force_posdef_covmatrix

    Default not used. Forces covariance matrix to be positive-definite.
EOF

$help_text{-force_m1_propagation} = <<'EOF';
    -force_m1_propagation

    Default not used. Forces the propagation of model 1 uncertainty, even when
    covariance step from model 4 was succesful (mainly useful for debugging/research).
EOF

$help_text{-force_posdef_samples} = <<'EOF';
    -force_posdef_samples

    Default not used. Forces each multivariate normal sample to be positive-
    definite (OMEGA and SIGMA blocks), instead of waiting for posdef samples to
    get drawn.
EOF

$help_text{-print_iter} = <<'EOF';
    -print_iter=N

    Optional, default is 0 (off). Every N:th (multivariate normal sampling)
    iteration will be printed with cumulative acceptance and rejection rates.
EOF

$help_text{-final_model} = <<'EOF';
    -final_model

    Default is to use model_4.mod in the frem final_models directory as the
    final FREM model, but this option can override this with another model
    present in the final_models directory.
EOF

common_options::online_help('postfrem', \%options,\%help_text, \%required_options, \%optional_options);
common_options::setup( \%options, 'postfrem' ); #calls set_globals etc, initiates random sequence

my $logger = logging::get_logger("postfrem");

# base files and folders
if(not defined $options{'frem_directory'} or (not -d $options{'frem_directory'}))  {
    die "must set -frem_directory to existing directory\n";
}

$options{'option_file'} = $options{'frem_directory'} . '/version_and_option_info.txt';

my $final_model;
if (defined $options{'final_model'}) {
    $final_model = File::Spec->catfile($options{'frem_directory'}, 'final_models', $options{'final_model'});
    if (not -f $final_model) {
        $logger->critical("must set -final_model to existing final FREM model\n"); die;
    }
} else {
    $final_model = File::Spec->catfile($options{'frem_directory'}, 'final_models', 'model_4.mod');
    $options{'model_impeval'} = $options{'frem_directory'}.'/final_models/model_4b.mod';
    if (-f $options{'model_impeval'}) {
        $logger->info("Model 4b (importance sampling evaluation) found");
    } else {
        $options{'model_impeval'} = undef;
    }
}

# find base model (FREM only copies base model results into dir if base model was not pre-executed)
$options{'base_model'}=$options{'frem_directory'}.'/m1/model_1.mod';
$options{'base_model'} // croak "Could not find base model $options{'base_model'}";
$options{'base_model_lst'}=$options{'frem_directory'}.'/m1/model_1.lst';
$options{'base_model_lst'} // croak "Could not find base model results $options{'base_model_lst'}";
$options{'base_model_cov'}=$options{'frem_directory'}.'/m1/model_1.cov';
$options{'frem_dataset'} = $options{'frem_directory'}.'/frem_dataset.dta';

if( defined $options{'sir_directory'} and (-d $options{'sir_directory'}))  {
    $options{'rawres_input'}=$options{'sir_directory'}.'/raw_results_model_4.csv';
    $options{'in_filter'}='resamples.gt.0';
    if (defined $options{'force_posdef_covmatrix'}) {
        warn "option -force_posdef_covmatrix not applicable to sir directory uncertainty";
    }
    if (defined $options{'force_m1_propagation'}) {
        warn "option -force_m1_propagation not applicable to sir directory uncertainty";
    }
}
if (defined $options{'output_format'}){
    unless ($options{'output_format'} =~ /^(pdf|png|svg|jpg)$/){
        die "Unsupported output format ".$options{'output_format'}."\n";
    }
}else{
    $options{'output_format'}="pdf";
}

my $print_iter_N = $options{'print_iter'} // 0;

require model;

sub get_empty_matrix
{
    my %parm = validated_hash(\@_,
        size => {isa => 'Int', optional => 0},
    );
    my $size = $parm{'size'};

    my $mat = [];
    for (my $i=0; $i<$size; $i++) {
        my $col = [(0) x $size];
        push @{$mat}, $col;
    }

    return $mat;
}
sub get_tri_coords
{
    my %parm = validated_hash(\@_,
        num => {isa => 'Int', optional => 0},
        size => {isa => 'Int', optional => 0},
        num_zero_start => {isa => 'Bool', default => 1, optional => 1},
    );
    my $num = $parm{'num'};
    my $size = $parm{'size'};
    my $num_zero_start = $parm{'num_zero_start'};

    my $count = $num_zero_start ? 0 : 1;
    for (my $i=1; $i<=$size; $i++) {
        for (my $j=1; $j<=$i; $j++) {
            return ($i, $j) if ($num == $count);
            $count++;
        }
    }
    croak("Linear coordinate $num is out of bounds in ${size}x${size} triangle");
    return (undef, undef);
}
sub get_lin_coord
{
    my %parm = validated_hash(\@_,
        x => {isa => 'Int', optional => 0},
        y => {isa => 'Int', optional => 0},
        size => {isa => 'Int', optional => 0},
        lin_zero_start => {isa => 'Bool', default => 1, optional => 1},
    );
    my $x = $parm{'x'};
    my $y = $parm{'y'};
    my $size = $parm{'size'};
    my $lin_zero_start = $parm{'lin_zero_start'};

    my $count = $lin_zero_start ? 0 : 1;
    for (my $i=1; $i<=$size; $i++) {
        for (my $j=1; $j<=$i; $j++) {
            return $count if ($i == $x && $j == $y);
            $count++;
        }
    }
    croak("Coordinates ($x, $y) are out of bounds in ${size}x${size} triangle");
    return undef;
}
sub write_covmatrix
{
    my %parm = validated_hash(\@_,
        matrix => {isa => 'ArrayRef[ArrayRef]', optional => 0},
        filename => {isa => 'Str', default => 1, optional => 0},
        nthetas => {isa => 'Int', optional => 0},
        nsigmas => {isa => 'Int', optional => 0},
        nomegas => {isa => 'Int', optional => 0},
    );
    my $matrix = $parm{'matrix'};
    my $filename = $parm{'filename'};
    my $nthetas = $parm{'nthetas'};
    my $nsigmas = $parm{'nsigmas'};
    my $nomegas = $parm{'nomegas'};

    # construct label vector
    my @labels;
    for (my $i=1; $i<=$nthetas; $i++) {
        my $name = "THETA$i";
        push @labels, $name;
    }
    for (my $i=1; $i<=$nsigmas; $i++) {
        for (my $j=1; $j<=$i; $j++) {
            my $name = "SIGMA($i,$j)";
            push @labels, $name;
        }
    }
    for (my $i=1; $i<=$nomegas; $i++) {
        for (my $j=1; $j<=$i; $j++) {
            my $name = "OMEGA($i,$j)";
            push @labels, $name;
        }
    }

    # copy and transpose
    my $mat = [];
    foreach my $col (@{$matrix}) {
        my @col_copy;
        foreach my $val (@{$col}) {
            push @col_copy, $val;
        }
        push @{$mat}, \@col_copy;
    }
    linear_algebra::transpose($mat);

    # output
    open(my $fh, '>', $filename) or croak("Could not open $filename for writing");
    print $fh "TABLE NO.     1: Covariance matrix output by write_covmatrix\n";
    my $format = ("%-12s " x (scalar(@labels)+1));
    printf $fh " $format\n", "NAME", @labels;
    for (my $row=0; $row<scalar(@{$mat}); $row++) {
        my $rvec = $matrix->[$row];
        my $format = "%-12s ".("%12.5E " x scalar(@labels));
        printf $fh " $format\n", $labels[$row], @{$rvec};
    }
    close $fh;
}
sub propagate_m1_to_m4_covmatrix
{
    my %parm = validated_hash(\@_,
        m1_covmat => {isa => 'ArrayRef[ArrayRef]', optional => 0},
        m4_omegas => {isa => 'ArrayRef[ArrayRef]', optional => 0},
        npar => {isa => 'Int', optional => 0},
        ncov => {isa => 'Int', optional => 0},
        thetas => {isa => 'Int', optional => 0},
        sigmas => {isa => 'Int', optional => 0},
        omegas => {isa => 'Int', optional => 0},
        nsubjects => {isa => 'Int', optional => 0},
        skip_omegas => {isa => 'ArrayRef[Int]', optional => 1},
    );
    my $m1_covmat = $parm{'m1_covmat'};
    my $m4_omegas = $parm{'m4_omegas'};
    my $npar = $parm{'npar'};
    my $ncov = $parm{'ncov'};
    my $thetas = $parm{'thetas'};
    my $sigmas = $parm{'sigmas'};
    my $omegas = $parm{'omegas'};
    my $nsubjects = $parm{'nsubjects'};
    my @skip_omegas = @{$parm{'skip_omegas'}};

    if (scalar(@skip_omegas) > 0) {
        # TODO: support skipped omegas
        print "Skipped omegas not yet supported for uncertainty propagation; skipping\n";
        return undef;
    }

    # sizes (without correlation terms)
    my $base_thetas = $thetas - $ncov; # no cov means
    my $base_sigmas = $sigmas - 1; # no FREM sigma
    my $base_omegas = $omegas - $ncov; # no cov variances

    # sizes with correlation terms
    my $covmat_sigmas = ($sigmas**2-$sigmas)/2 + $sigmas;
    my $covmat_omegas = ($omegas**2-$omegas)/2 + $omegas;
    my $covmat_parcov_omegas = $npar*$ncov;
    my $covmat_size = $thetas + $covmat_sigmas + $covmat_omegas;
    my $base_covmat_sigmas = ($base_sigmas**2-$base_sigmas)/2 + $base_sigmas;
    my $base_covmat_omegas = ($base_omegas**2-$base_omegas)/2 + $base_omegas;
    my $base_covmat_size = $base_thetas + $base_covmat_sigmas + $base_covmat_omegas;
    # parameter types in covmatrices
    my @base_ptype = (
        ('theta') x $base_thetas,
        ('sigma') x $base_covmat_sigmas,
        ('omega') x $base_covmat_omegas,
    );
    my %base_ptype_start = (
        'theta' => 0,
        'sigma' => $base_thetas,
        'omega' => ($base_thetas + $base_covmat_sigmas),
    );
    my @ptype = (
        ('theta') x ($thetas - $ncov),
        ('cov-theta') x $ncov,
        ('sigma') x $base_covmat_sigmas,
        ('cov-sigma') x ($covmat_sigmas - $base_covmat_sigmas),
        ('omega') x $base_covmat_omegas,
        ('parcov-omega') x $covmat_parcov_omegas,
        ('cov-omega') x ($covmat_omegas - $base_covmat_omegas - $covmat_parcov_omegas),
    );
    my %ptype_start = ('theta' => 0);
    for (my $i=1; $i<scalar(@ptype); $i++) {
        $ptype_start{$ptype[$i]} = $i if ($ptype[$i] ne $ptype[$i-1]);
    }

    # construct empty SE matrix of M4
    my $covmat = get_empty_matrix(size => $covmat_size);

    # get effective number of subjects (estimated information content) for each omega of M4
    my @eff_n = ($nsubjects) x ($covmat_size); # default to maximum information
    for (my $i=0; $i<$covmat_size; $i++) {
        if ($ptype[$i] eq 'omega' || $ptype[$i] eq 'parcov-omega') { # omega's associated with PK parameters do not have perfect information
            # get omega ordinal number (linear omega coordinate)
            my $om_i = $i - $ptype_start{'omega'};

            # get matrix coordinates and corresponding variance estimates for both in correlation
            my @om_tri = get_tri_coords(num => $om_i, size => $omegas, num_zero_start => 1);
            my @var = ($m4_omegas->[$om_tri[0]-1]->[$om_tri[0]-1], $m4_omegas->[$om_tri[1]-1]->[$om_tri[1]-1]);
            # print "\nLinear om $om_i : OMEGA($om_tri[0], $om_tri[1]) : var $var[0] & var $var[1]\n";

            # calculate information content for both and choose the lowest for this correlation
            my @eff = (0, 0);
            for (my $i=0; $i<=1; $i++) {
                if ($om_tri[$i] > $base_omegas) {
                    $eff[$i] = $nsubjects;
                } else {
                    my $base_lin = get_lin_coord(x => $om_tri[$i], y => $om_tri[$i], size => $omegas, lin_zero_start => 1);
                    $base_lin = $base_lin + $base_ptype_start{'omega'};
                    my $se = sqrt($m1_covmat->[$base_lin]->[$base_lin]);
                    # print "se $se\n";
                    $eff[$i] = 1 + 2*($var[$i]**2 / $se**2);
                    if ($eff[$i] > $nsubjects) {
                        print "Warning: SE of OMEGA($om_tri[$i],$om_tri[$i]) estimated with high effective N=$eff[$i] (compare to Nsubj=$nsubjects)\n";
                    }
                }
            }
            # print "eff $eff[0] & eff $eff[1]\n";
            $eff_n[$i] = ($eff[0] < $eff[1]) ? $eff[0] : $eff[1];
        }
        # TODO: adjust effective number of subjects also for covariates (e.g. when missing)
    }

    # fill M4 covariance matrix (copy + calculate diagonal for new estimators)
    for (my $col=0; $col<$covmat_size; $col++) {
        for (my $row=0; $row<=$col; $row++) {
            if (    $ptype[$col] eq 'theta' || $ptype[$col] eq 'omega' || $ptype[$col] eq 'sigma'
                and $ptype[$row] eq 'theta' || $ptype[$row] eq 'omega' || $ptype[$row] eq 'sigma') { # must exist in old matrix
                # get index of parameter type (0 for first theta, first omega or first sigma)
                my $col_par_i = $col - $ptype_start{ $ptype[$col] };
                my $row_par_i = $row - $ptype_start{ $ptype[$row] };

                # get corresponding column and row of old matrix
                my $old_col = $col_par_i + $base_ptype_start{ $ptype[$col] };
                my $old_row = $row_par_i + $base_ptype_start{ $ptype[$row] };

                # copy element from old matrix
                my $old_val = $m1_covmat->[$old_col]->[$old_row];
                $covmat->[$col]->[$row] = $old_val;

                # just debug output
                if ($options{'force_m1_propagation'}) {
                    my @names;
                    my @types = ($ptype[$col], $ptype[$row]);
                    my @indices = ($col_par_i, $row_par_i);
                    for (my $i=0; $i<=1; $i++) {
                        my $type = $types[$i];
                        my $index = $indices[$i];
                        if ($type eq 'theta') {
                            push @names, "THETA".($index+1);
                        } elsif ($type eq 'omega') {
                            my ($num_a, $num_b) = get_tri_coords(num => $index, size => $omegas, num_zero_start => 1);
                            push @names, "OMEGA($num_a,$num_b)";
                        } elsif ($type eq 'sigma') {
                            my ($num_a, $num_b) = get_tri_coords(num => $index, size => $sigmas, num_zero_start => 1);
                            push @names, "SIGMA($num_a,$num_b)";
                        }
                    }
                    printf "SE for %-12s - %-12s copied over (%12.5E)\n", $names[0], $names[1], $old_val;
                }
            } elsif ($col == $row) { # fill diagonal
                my $se = 0; # e.g. for cov-sigma (since FREM sigma is fixed)
                if ($ptype[$col] eq 'cov-theta') {
                    $se = 0; # TODO: might do something smarter here
                } elsif ($ptype[$col] eq 'parcov-omega' || $ptype[$col] eq 'cov-omega') {
                    my $om_i = $col - $ptype_start{'omega'};
                    my @om_tri = get_tri_coords(num => $om_i, size => $omegas, num_zero_start => 1);
                    if ($om_tri[0] == $om_tri[1]) { # variance estimator
                        my $var = $m4_omegas->[$om_tri[0]-1]->[$om_tri[1]-1];
                        $se = $var*sqrt(2/($eff_n[$col]-1));
                    } else { # covariance estimator
                        my @var = ($m4_omegas->[$om_tri[0]-1]->[$om_tri[0]-1], $m4_omegas->[$om_tri[1]-1]->[$om_tri[1]-1]);
                        my $covar = $m4_omegas->[$om_tri[0]-1]->[$om_tri[1]-1];
                        $se = sqrt(($covar^2 + $var[0]*$var[1])/$eff_n[$col])
                    }
                    # TODO: get 4th moment from phi file and use to estimate better uncertainty
                }

                my $element = $se**2;
                $covmat->[$col]->[$row] = $element if ($se != 0);

                # just debug output
                if ($options{'force_m1_propagation'}) {
                    my @names;
                    my @types = ($ptype[$col], $ptype[$row]);
                    my @indices = ($col, $row);
                    for (my $i=0; $i<=1; $i++) {
                        my $type = $types[$i];
                        my $index = $indices[$i];
                        if ($type =~ /theta$/) {
                            $index = $index - $ptype_start{'theta'};
                            push @names, "THETA".($index+1);
                        } elsif ($type =~ /sigma$/) {
                            $index = $index - $ptype_start{'sigma'};
                            my ($num_a, $num_b) = get_tri_coords(num => $index, size => $sigmas, num_zero_start => 1);
                            push @names, "SIGMA($num_a,$num_b)";
                        } elsif ($type =~ /omega$/) {
                            $index = $index - $ptype_start{'omega'};
                            my ($num_a, $num_b) = get_tri_coords(num => $index, size => $omegas, num_zero_start => 1);
                            push @names, "OMEGA($num_a,$num_b)";
                        }
                    }
                    if ($se != 0) {
                        printf "SE for %-12s - %-12s set to new  (%12.5E)\n", $names[0], $names[1], $element;
                    } else {
                        printf "SE for %-12s - %-12s set to zero (%12.5E)\n", $names[0], $names[1], $element;
                    }
                }
            }
        }
        # symmetrize
        for (my $i=0; $i<$col; $i++) {
            $covmat->[$i]->[$col] = $covmat->[$col]->[$i];
        }
    }

    return $covmat;
}
sub remove_params_in_covmatrix
{
    my %parm = validated_hash(\@_,
        covmatrix => {isa => 'ArrayRef[ArrayRef]', optional => 0},
        thetas => {isa => 'ArrayRef', optional => 0},
        sigmas => {isa => 'ArrayRef', optional => 0},
        omegas => {isa => 'ArrayRef', optional => 0},
    );
    my $covmatrix = $parm{'covmatrix'};
    my $thetas = $parm{'thetas'};
    my $sigmas = $parm{'sigmas'};
    my $omegas = $parm{'omegas'};

    my @params = (@{$thetas}, @{$sigmas}, @{$omegas});

    my $nparams = scalar(@params);
    my $ncols = scalar(@{$covmatrix});
    croak "$nparams parameters while \$covmatrix has $ncols columns" if ($nparams != $ncols);

    # get new size of matrix (after erasure)
    my $new_size = 0;
    foreach my $param (@params) {
        $new_size++ unless ($param);
    }
    my $new_covmatrix = get_empty_matrix(size => $new_size);

    # copy only non-marked parameters over
    for (my $i=0, my $new_i=0; $i<$ncols; $i++) {
        next if ($params[$i]);

        my $nrows = scalar(@{$covmatrix->[$i]});
        croak "column $i has $nrows rows but matrix has $ncols columns" if ($nrows != $ncols);

        for (my $j=0, my $new_j=0; $j<scalar(@{$covmatrix->[$i]}); $j++) {
            next if ($params[$j]);

            $new_covmatrix->[$new_i]->[$new_j] = $covmatrix->[$i]->[$j];
            $new_j++;
        }
        $new_i++;
    }

    return $new_covmatrix;
}

## Set the automatic renaming of modelfit directory
chdir($options{'frem_directory'});
my $main_directory = tool::get_rundir(
    create => 1,
    basename => 'postfrem',
    directory_option => $options{'directory'},
);
chdir("..");

my @outputfiles;


my $eval_string = common_options::model_parameters(\%options);

if( scalar @ARGV > 0 ) {
  die "missing -optionsname?\n";
}

my $NA_string = ""; # for values missing when no uncertainty (point estimates only)

my $model = model->new ( eval( $eval_string ),
                         filename => $final_model,
                         ignore_missing_output_files => 1 );
my $model_impeval;
if (defined $options{'model_impeval'}) {
    $model_impeval = model->new( eval( $eval_string ),
                                 filename => $options{'model_impeval'},
                                 ignore_missing_output_files => 1 );
}
unless (defined $options{'frem_dataset'}) {
    $options{'frem_dataset'} = $model->problems->[0]->datas->[0]->get_absolute_filename();
    $logger->info("Using FREM dataset ".$options{'frem_dataset'});
}
unless (-f $options{'frem_dataset'}) {
    $logger->critical("Could not read FREM dataset ".$options{'frem_dataset'}); die;
}

# set covariate summary file (will replace re-calculation of covariate stats)
my $file = 'covariates_summary.csv';
my ($vol, $dir, undef) = File::Spec->splitpath($options{'frem_dataset'});
my $cov_summary = File::Spec->catpath($vol, $dir, $file);
unless (-f $cov_summary) {
    $logger->critical("Could not read $cov_summary"); die;
}

# get FREM post-processing data (# subjects, covariate data, number of parameters, etc.)
my ($covn,$resc,$omegaindex,$parn,$size,$emeans,$evar) = tool::frem::get_post_processing_data(model => $model);
my @cov_rescale = @{$resc};
my @covnames = @{$covn};
my @parnames = @{$parn};
my @est_cov_means = @{$emeans};
my @est_cov_variances = @{$evar};
my $npar = scalar(@parnames);
my $ncov = scalar(@covnames);

# get covariate statistics post-processing data (TODO: shall start to replace read_covdata below)
my $covdata = tool::frem::read_covresults(covnames => $covn, filename => $cov_summary);
unless (defined $covdata) {
    $logger->critical("covariate summary read error, can't continue"); die;
}
my @cov_means = @{ $covdata->{'invariant_mean'} };

my ($cov_5th,$cov_95th,$id_covariate_vectors,$categorical,$categoryinfo) =
    tool::frem::read_covdata(covnames => \@covnames,
                             filename => $options{'frem_dataset'});

my @tvpar = ();
my @cov_reference = ();
my @cov_units=();

for (my $i=0; $i<$ncov; $i++){
    my $cn = $covnames[$i];
    if ($categorical->[$i]){
        push(@cov_reference,$categoryinfo->{$cn}->{'reference'});
        push(@cov_units,'');
    }else{
        push(@cov_reference,$cov_means[$i]);
        if (defined $units{$cn}){
            push(@cov_units,$units{$cn});
        }else{
            push(@cov_units,'');
        }
    }
}

my @labels=(@parnames,@covnames);
my $id_count = scalar(@{$id_covariate_vectors});

my $m4_nthetas = $model->nthetas;
my $m4_nsigmas = $model->nsigmas->[0];
my $m4_nomegas = $model->nomegas->[0];


# get uncertainty and simulate parameter vectors
my $have_uncertainty;
my $propagated_covmatrix; # only for disk write later
my $sampled_params_arr;
my $match_labels;
if (defined $options{'rawres_input'}) {
    # e.g. user specified a sir directory
    my ($center_params_arr,$href2) = model::get_rawres_params(filename => $options{'rawres_input'},
                                                              filter => [],
                                                              offset => 0,
                                                              only_first_match => 1,
                                                              model => $model);
    if (defined $center_params_arr and scalar(@{$center_params_arr} == 1)){
        $model -> update_inits(from_hash => $center_params_arr->[0]);
    }else{
        croak("error reading center estimates from sir raw results file");
    }
    $match_labels=1;
    $have_uncertainty=1;
} else {
    $match_labels=0;
    #i.e. did not set sir_directory
    #check if have covstep of model 4
    $logger->info("Trying to use covariance step results from FREM model");
    unless (defined $model->outputs and defined $model->outputs->[0] and -f $model->outputs->[0]->full_name){
        $logger->critical("No output from FREM model"); die;
    }
    $model->update_inits( from_output => $model->outputs->[0],
                          ensure_posdef => 0,
                          ignore_missing_parameters => 0,
                          update_fix => 0);

    my $covmatrix;
    if ($model->outputs->[0]->get_single_value(attribute => 'covariance_step_successful')) {
        $covmatrix = tool::sir::get_nonmem_covmatrix(output => $model->outputs->[0]);
    } elsif (defined $model_impeval) {
        if ($model_impeval->outputs->[0]->get_single_value(attribute => 'covariance_step_successful')) {
            $covmatrix = tool::sir::get_nonmem_covmatrix(output => $model_impeval->outputs->[0]);
            $logger->info("Model 4b (importance sampling evaluation) covariance matrix read");
        }
    }
    unless (defined $covmatrix) {
        $logger->warning("Covariance step was not succesful\n");
    }

    # M1 uncertainty can be propagated down as a fallback for missing M4 uncertainty
    if (!defined $covmatrix or $options{'force_m1_propagation'}) {
        unless (defined $options{'base_model'}) {
            $logger->warning("No base model to propagate uncertainty from");
        } else {
            print "Trying to propagate model_1 (base model) uncertainty\n";
            my $base_model = model->new( eval( $eval_string ),
                                         filename => $options{'base_model'},
                                         ignore_missing_output_files => 1 );
            if (defined $base_model->outputs and defined $base_model->outputs->[0]) {
                $base_model->update_inits( from_output => $base_model->outputs->[0],
                                           ensure_posdef => 0,
                                           ignore_missing_parameters => 0,
                                           update_fix => 0 );

                my $base_covmatrix;
                if ($base_model->outputs->[0]->get_single_value(attribute => 'covariance_step_successful') && -f $options{'base_model_cov'}) {
                    $base_covmatrix = tool::sir::get_nonmem_covmatrix(output => $base_model->outputs->[0]);
                    my $posdef_err = tool::sir::check_matrix_posdef(matrix => $base_covmatrix);
                    if ($posdef_err == 1) {
                        print "Covariance matrix is numerically not positive definite (check that model_1 covariance step is OK)\n".
                              "(as checked with Cholesky decomposition without pivoting)\n";
                    } else {
                        # M1 has good uncertainty which we'll try to use
                        my $opt_file = $options{'option_file'};
                        my $opt_read;
                        my @skip_omegas;
                        if (-e $opt_file) {
                            open my $fh, '<', $opt_file;
                            while (<$fh>) {
                                if (/^-skip_omegas=(.*)$/) {
                                    if ($1 ne "") {
                                        chomp($1);
                                        @skip_omegas = split(/,/, $1);
                                    }
                                    $opt_read = 1;
                                }
                            }
                            close $fh;
                        }
                        if ($opt_read) {
                            # get full SE matrix of M1 in table form (needed to not remove 0-rows and -cols) and create array matrix form
                            my $m1_covmat_table = nmtablefile->new(filename => $options{'base_model_cov'})->get_table(index => 0);
                            my $m1_covmat_size = scalar(@{$m1_covmat_table->columns})-1; # skip NAME column
                            my $m1_covmat = [];
                            for (my $i=1; $i<=$m1_covmat_size; $i++) {
                                push @{$m1_covmat}, $m1_covmat_table->get_column(index => $i);
                            }

                            # get full omega matrices of M4 (including 0:s where none were estimated)
                            my $m4_omegas = $model->problems->[0]->get_matrix(type => 'omega', start_row => 1);

                            $propagated_covmatrix = propagate_m1_to_m4_covmatrix(
                                m1_covmat => $m1_covmat,
                                m4_omegas => $m4_omegas,
                                npar => $npar,
                                ncov => $ncov,
                                thetas => $m4_nthetas,
                                sigmas => $m4_nsigmas,
                                omegas => $m4_nomegas,
                                nsubjects => $id_count,
                                skip_omegas => \@skip_omegas,
                            );
                        } else {
                            print "Could not read skipped omegas information from $options{'option_file'}; skipping\n";
                        }
                        if (defined $propagated_covmatrix) {
                            # remove fixed parameters
                            $covmatrix = remove_params_in_covmatrix(
                                covmatrix => $propagated_covmatrix,
                                thetas => $model->fillblock_fixed(parameter_type => 'theta')->[0],
                                sigmas => $model->fillblock_fixed(parameter_type => 'sigma')->[0],
                                omegas => $model->fillblock_fixed(parameter_type => 'omega')->[0],
                            );
                        }
                    }
                } else {
                    print "Covariance step of model_1 was not succesful, not run or .cov file not found\n";
                }
            } else {
                die "No output from model_1 in frem directory";
            }
        }
    }
    if (defined $covmatrix)    {
        my $posdef_err = tool::sir::check_matrix_posdef(matrix => $covmatrix);
        if ($posdef_err == 1){
            if (defined $propagated_covmatrix) {
                print "Propagated model_1 uncertainty resulted in not numerically positive definite matrix\n".
                      "(this is to be expected; not all elements can be constructed)\n";
            } else {
                print "Covariance matrix is numerically not positive definite (check that covariance step is OK)\n".
                      "(as checked with Cholesky decomposition without pivoting)\n";
            }
            if (defined $options{'force_posdef_covmatrix'} or defined $propagated_covmatrix) {
                # force positive definite
                print "Forcing matrix positive definite\n";
                (my $covmatrix_posdef, my $count) = linear_algebra::get_symmetric_posdef(
                    matrix => $covmatrix,
                    minEigen => 1E-10,
                );
                print "$count eigenvalue(s) adjusted\n";

                # copy and test that this modification is good enough for cholesky decomp
                my $covmatrix_copy = [];
                for (my $i=0; $i < scalar(@{$covmatrix_posdef}); $i++) {
                    my $row_copy = [];
                    my $row = $covmatrix_posdef->[$i];
                    for (my $j=0; $j < scalar(@{$row}); $j++) {
                        push(@{$row_copy}, $row->[$j]);
                    }
                    push(@{$covmatrix_copy}, $row_copy);
                }
                my $err = linear_algebra::cholesky($covmatrix_copy);
                if ($err > 0) {
                    die "cholesky error $err after get_symmetric_posdef\n";
                }

                # output metrics of adjustment bias
                my $norm_of_diff = tool::frem::neat_num( num=>linear_algebra::frobenius_norm(matrix => $covmatrix, matrix2 => $covmatrix_posdef) );
                my $direct_diff = tool::frem::neat_num( num=>linear_algebra::matrix_rmse(matrix1 => $covmatrix, matrix2 => $covmatrix_posdef, method => 1) );
                my $id_diff = tool::frem::neat_num( num=>linear_algebra::matrix_rmse(matrix1 => $covmatrix, matrix2 => $covmatrix_posdef, method => 2) );
                my $cnum_orig = linear_algebra::condition_number($covmatrix);
                my $cnum_adj = linear_algebra::condition_number($covmatrix_posdef);
                my $cnum_change = "";
                if (defined $cnum_orig) {
                    $cnum_change = ($cnum_adj/$cnum_orig);
                    if ($cnum_change > 1) {
                        my $fac = tool::frem::neat_num(num=>$cnum_adj/$cnum_orig);
                        $cnum_change = "($fac times larger)";
                    } else {
                        my $fac = tool::frem::neat_num(num=>$cnum_orig/$cnum_adj);
                        $cnum_change = "($fac times smaller)";
                    }
                    $cnum_orig = tool::frem::neat_num(num=>$cnum_orig);
                } else {
                    $cnum_orig = "[NA]";
                }
                $cnum_adj = tool::frem::neat_num(num=>$cnum_adj);
                # $logger->info("Absolute difference of frobenius norms: $diff_of_norms");
                $logger->info("Frobenius norm of difference matrix (prop. to RMSE): $norm_of_diff");
                $logger->warning("RMSE of adjustments: $direct_diff");
                $logger->warning("RMSE of inverse product to identity matrix: $id_diff");
                $logger->warning("(large values indicate matrix might be severely affected by adjustments)");
                $logger->warning("Condition number changed from $cnum_orig to $cnum_adj $cnum_change");

                $covmatrix = $covmatrix_posdef;
                $posdef_err=0;
            } else {
                # covariance matrix not positive definite and not forcing: no uncertainty
                $have_uncertainty=0;
            }
        }
        if ($posdef_err != 1) {
            # use valid covariance matrix for uncertainty
            my $parameter_hash = output::get_nonmem_parameters(output => $model->outputs->[0]);
            print "Sampling from the truncated multivariate normal distribution\n";
            if ($options{'force_posdef_samples'}) {
                print "(adjusting all OMEGA and SIGMA sampled blocks to positive-definiteness)\n";
            }
            my $mu_values= $parameter_hash->{'values'};

            my $mat = new Math::MatrixReal(1,1);
            my $muvector = $mat->new_from_rows( [$mu_values] );
            my ($vectorsamples,$boxcox_samples) = tool::sir::sample_multivariate_normal(
                check_cholesky_reparameterization => 0,
                fix_theta_labels => [],
                fix_theta_values => [],
                samples=>1000,
                labels => $parameter_hash->{'labels'},
                covmatrix => $covmatrix,
                inflation => [],
                adjust_blocks => $options{'force_posdef_samples'},
                minEigen => 1E-10,
                lower_bound => $parameter_hash->{'lower_bounds'},
                upper_bound => $parameter_hash->{'upper_bounds'},
                param => $parameter_hash->{'param'},
                coords => $parameter_hash->{'coords'},
                block_number => $parameter_hash->{'block_number'},
                choleskyform => $parameter_hash->{'choleskyform'},
                mu => $muvector,
                lambda => [],
                delta => [],
                fast_posdef_checks => 1,
                print_iter_N => $print_iter_N,
                directory => $main_directory,
            );

            $sampled_params_arr = tool::sir::create_sampled_params_arr(samples_array => $vectorsamples,
                                                                       labels_hash => $parameter_hash,
                                                                       user_labels => 0);
            $have_uncertainty=1;
        }
    } else {
        # no sir directory & no covariance matrix: no uncertainty
        $have_uncertainty=0;
    }
}

if ($have_uncertainty) {
    if (defined $options{'rawres_input'}){
        my $href;
        my $samples;
        my $offset=1;
        $offset= $options{'offset_rawres'} if (defined $options{'offset_rawres'});
        my @in_filter=();
        if ( defined $options{'in_filter'} ){
            #split string, assume comma separated
            foreach my $filt (split(/,/,$options{'in_filter'})){
                if ($filt =~ /.\.(gt|lt|eq)\.\d+\.?\d*/){
                    push(@in_filter,$filt);
                }else{
                    die "Input filter $filt does not fulfill the format rules.\n";
                }
            }
            if (scalar(@in_filter)<1){
                die "Error: Option in_filter used, but list of conditions could not be parsed.\n";
            }
        }

        ($sampled_params_arr,$href) = model::get_rawres_params(filename => $options{'rawres_input'},
                                                               filter => \@in_filter,
                                                               offset => $offset,
                                                               model => $model);
    }

    if (defined $sampled_params_arr) {
        unless (scalar(@{$sampled_params_arr}) >= $minimum) {
            if (defined $options{'in_filter'}) {
             croak("Too few sets (lines) of parameter values in\n".
                     "rawres file after filtering. Have ".
            scalar(@{$sampled_params_arr})." but need at least $minimum\n");
            } else {
                croak("Too few sets (lines) of parameter values in\n".
                  "rawres file. Have ".scalar(@{$sampled_params_arr}).
                  " but need at least $minimum plus offset\n");
            }
        }
    } else {
       croak("get_rawres_params returned undef");
    }
} else {
    print "All attempts at getting uncertainty failed (only point estimates available)\n";
}

my $index=0;
unless (scalar(@labels)==$size){
    croak("size is $size but label count is ".scalar(@labels));
}

chdir($main_directory); #created by tool::get_rundir

# write covariance matrix if m1 uncertainty has been used (i.e. we made this matrix)
if (defined $propagated_covmatrix) {
    my $filename = 'model_4.cov';
    write_covmatrix(
        matrix => $propagated_covmatrix,
        filename => $filename,
        nthetas => $m4_nthetas,
        nsigmas => $m4_nsigmas,
        nomegas => $m4_nomegas
    );
    print "Constructed (base model uncertainty propagated) model_4 covariance matrix: $options{'directory'}$filename\n";
}

my %coeff_arrays=();
my %variance_arrays=();
my %id_ratio_arrays=();
foreach my $par (@parnames){
    $id_ratio_arrays{$par}={};
    $coeff_arrays{$par}={};
    $coeff_arrays{$par}->{'all'} = [];
    $variance_arrays{$par}={};
    $variance_arrays{$par}->{'none'} = [];
    $variance_arrays{$par}->{'all'} = [];
    foreach my $cov (@covnames){
        $coeff_arrays{$par}->{$cov} = [];
        $variance_arrays{$par}->{$cov} = [];
    }
    for (my $l=0; $l< $id_count; $l++){
        #idnum
        $id_ratio_arrays{$par}->{$id_covariate_vectors->[$l]->[0]}=[];
    }
}


my $idcovdata = 'id_covdata.csv';
my $pardatafile = 'pardata.csv';
my $covdatafile = 'covdata.csv';

open (my $idfh, '>',$idcovdata) or die ("cannot open < ".$idcovdata.": $!");
print $idfh 'ID,'.join(',',@covnames)."\n";
for (my $l=0; $l< $id_count; $l++){
    print $idfh join(',',@{$id_covariate_vectors->[$l]})."\n";
}
close $idfh;

open( FILE1, '>'.$pardatafile );
print FILE1 'parname'."\n";
for (my $i=0; $i< scalar(@parnames); $i++){
    print FILE1 '"'.$parnames[$i].'"'."\n";
}
close FILE1;

open( FILE2, '>'.$covdatafile );
print FILE2 'covname,perc5th,mean,perc95th,reference,is.categorical,unit,category.reference,category.other'."\n";
for (my $i=0; $i< scalar(@covnames); $i++){
    my $string = $covnames[$i].','.$cov_5th->[$i].','.$cov_means[$i].','.$cov_95th->[$i].','.$cov_reference[$i].','.$categorical->[$i].','.$cov_units[$i].',';
    if ($categorical->[$i]){
        my $ref = $categoryinfo->{$covnames[$i]}->{'reference'};
        my $other = $categoryinfo->{$covnames[$i]}->{'other'};
        if (defined $categorytext{$covnames[$i]}){
            $string .= $categorytext{$covnames[$i]}->{$ref}.','.$categorytext{$covnames[$i]}->{$other};
        }else{
            $string .= $ref.','.$other;
        }
    }else{
        $string .= ',';
    }
    print FILE2 $string."\n";
}
close FILE2;



my @rescale = (1) x $npar;
push(@rescale,@cov_rescale);
unless (scalar(@rescale)==$size){
    croak("length rescale is ".scalar(@rescale)." size is $size");
}

my $ratioheader='sample';
my $varheader='sample';


#1. none
#2. per cov
#3. all
for (my $i=0;$i<$npar; $i++){
    $varheader .= ',"CONDVAR.par.'.$labels[$i].'.given.none"';
}
for (my $j=$npar;$j<$size; $j++){
    for (my $i=0;$i<$npar; $i++){
        $varheader .= ',"CONDVAR.par.'.$labels[$i].'.given.cov.'.$labels[$j].'"';
    }
}
for (my $i=0;$i<$npar; $i++){
    $varheader .= ',"CONDVAR.par.'.$labels[$i].'.given.allcov"';
}



#1. per cov
#FIXME separate files all, given individual covariates
for (my $j=$npar;$j<$size; $j++){
    my $covindex  = $j-$npar;
    for (my $i=0;$i<$npar; $i++){
        if ($categorical->[$covindex]){
            $ratioheader .= ',"RATIO.par.'.$labels[$i].'.given.other.'.$labels[$j].'"';
        }else{
            $ratioheader .= ',"RATIO.par.'.$labels[$i].'.given.cov5th.'.$labels[$j].'"';
            $ratioheader .= ',"RATIO.par.'.$labels[$i].'.given.cov95th.'.$labels[$j].'"';
        }
    }
}

my $fremratio = 'frem_ratio.csv';
open( RATIOFILE, '>'.$fremratio );
print RATIOFILE "$ratioheader\n";
open( VARFILE, '>frem_condvar.csv' );
print VARFILE "$varheader\n";

# calculate from distribution of samples
my $nsamples = $have_uncertainty ? scalar(@{$sampled_params_arr}) : 0;
for (my $k=0;$k<=$nsamples; $k++){
    if ($k != 0) {
        $model -> update_inits(from_hash => $sampled_params_arr->[$k-1],
                               match_labels => $match_labels);
    }
    my $varcov = $model->problems->[0]->omegas->[$omegaindex]->get_matrix;
    my $error;

    my $ratiovec = "$k";
    my $variancevec = "$k";
    for (my $i=0;$i<$npar; $i++){
        $variancevec .= ','.$varcov->[$i]->[$i];
        push(@{$variance_arrays{$labels[$i]}->{'none'}},$varcov->[$i]->[$i]);
    }
    my ($error,$cond_covar,$coeff);
    for (my $j=$npar;$j<$size; $j++){ #foreach covariate
        ($error,$cond_covar,$coeff) = linear_algebra::conditional_covariance_coefficients(varcov => $varcov,
                                                                                          rescaling => \@rescale,
                                                                                          cov_index_first => $j,
                                                                                          cov_index_last => $j,
                                                                                          par_index_first => 0,
                                                                                          par_index_last => ($npar-1));
        croak("cond covar coeff failed") if ($error != 0);
        my $covindex  = $j-$npar;
        for (my $i=0;$i<$npar; $i++){
            if ($categorical->[$covindex]){
                $ratiovec .= ','.exp(($categoryinfo->{$labels[$j]}->{'diff'})*($coeff->[$i]->[0]));
            }else{
                $ratiovec .= ','.exp(($cov_5th->[$covindex]-$cov_means[$covindex])*($coeff->[$i]->[0]));
                $ratiovec .= ','.exp(($cov_95th->[$covindex]-$cov_means[$covindex])*($coeff->[$i]->[0]));
            }
            $variancevec .= ','.$cond_covar->[$i]->[$i];
            push(@{$variance_arrays{$labels[$i]}->{$labels[$j]}},$cond_covar->[$i]->[$i]);
            if ($k==0){
                push(@{$coeff_arrays{$labels[$i]}->{$labels[$j]}},$coeff->[$i]->[0]);
                #push the parameterization
                my $str = sprintf("%.3E",$coeff->[$i]->[0]).'*('.$covnames[$covindex].'-'.sprintf("%.4g",$cov_means[$covindex]).')';
                push(@{$coeff_arrays{$labels[$i]}->{$labels[$j]}},$str);
            }
        }
    }
    #all covariates
    ($error,$cond_covar,$coeff) = linear_algebra::conditional_covariance_coefficients(varcov => $varcov,
                                                                                      rescaling => \@rescale,
                                                                                      cov_index_first => $npar,
                                                                                      cov_index_last => ($size-1),
                                                                                      par_index_first => 0,
                                                                                      par_index_last => ($npar-1));
    croak("cond covar coeff failed") if ($error != 0);
    for (my $i=0;$i<$npar; $i++){
        $variancevec .= ','.$cond_covar->[$i]->[$i];
        push(@{$variance_arrays{$labels[$i]}->{'all'}},$cond_covar->[$i]->[$i]);
        if ($k==0){
            push(@{$coeff_arrays{$labels[$i]}->{'all'}},join(',',@{$coeff->[$i]})); # a string
            #push the parameterization
            my $str = '';
            for (my $covindex=0; $covindex<($size-$npar); $covindex++){
                #sign!!!
                if (($covindex >0) and ($coeff->[$i]->[$covindex] > 0)){
                    $str .= '+'
                }
                $str .= sprintf("%.3E",$coeff->[$i]->[$covindex]).'*('.$covnames[$covindex].'-'.sprintf("%.4g",$cov_means[$covindex]).')';
            }
            push(@{$coeff_arrays{$labels[$i]}->{'all'}},$str);
        }
        for (my $l=0; $l<$id_count; $l++){
            my $num=0;
            for (my $j=0;$j<($size-$npar); $j++){ #foreach covariate
                $num += ($id_covariate_vectors->[$l]->[$j+1]-$cov_reference[$j] )*($coeff->[$i]->[$j]);
            }
            push(@{$id_ratio_arrays{$labels[$i]}->{$id_covariate_vectors->[$l]->[0]}},exp($num));
        }
    }

    print RATIOFILE "$ratiovec\n";
    print VARFILE "$variancevec\n";
}
close( RATIOFILE );
close( VARFILE );

my @probs = (0.05,0.95);
my $header = 'ID';

for (my $j=0;$j<($size-$npar); $j++){ #foreach covariate
    $header .= ',cov.'.$covnames[$j];
}


for (my $i=0;$i<$npar; $i++){
    $header .= ',"'.$parnames[$i].'.observed"';
    for (my $l=0; $l<scalar(@probs); $l++){
        $header .= ',"'.$parnames[$i].'.'.($probs[$l]*100).'th"';
    }
}
my $idratiosfile = 'frem_id_ratios.csv';
my $parfh;
open($parfh,'>',$idratiosfile) or die "cannot open < $idratiosfile: $!";
print {$parfh} "$header\n";

for (my $l=0; $l<$id_count; $l++){
    my $idnum = $id_covariate_vectors->[$l]->[0];
    my $idline = $idnum;
    for (my $j=0;$j<($size-$npar); $j++){ #foreach covariate
        $idline .= ','.$id_covariate_vectors->[$l]->[$j+1]; #+1 since 0 is idnum
    }

    for (my $i=0;$i<$npar; $i++){
        my $par = $labels[$i];
        my $observed = shift(@{$id_ratio_arrays{$par}->{$idnum}});
        $idline .= ','.$observed;
        my $quantref;
        if ($have_uncertainty) {
            my @sorted = (sort {$a <=> $b} @{$id_ratio_arrays{$par}->{$idnum}}); #sort ascending
            $quantref = quantile(probs => \@probs, numbers=> \@sorted);
        }
        for (my $k=0; $k< scalar(@probs); $k++){
            # NA in quantiles columns if we are in point estimate mode
            my $value = $have_uncertainty ? $quantref->[$k] : $NA_string;
            $idline .= ','.$value;
        }
    }
    print {$parfh} "$idline\n";
}
close($parfh);


#wikipedia: SD(x) lognormal with mu 0 and sigma :
#exp(0.5*sigma^2)*sqrt(exp(sigma^2)-1)
#estimate is $tvpar[$i]

sub get_cv{
    my $var=shift;
    my $est = shift;
    return 100*(exp(0.5*$var)*sqrt(exp($var)-1)); #SD
}


@probs = (0.05,0.95);
$header = 'par.conditionedOn,observed.sd,sd.5th,sd.95th';
foreach my $cov (@covnames){
    $header .= ',coeff.'.$cov;
}
$header .= ',parameterization';
my $name = 'sd_coefficients_summary.csv';

open($parfh,'>',$name) or die "cannot open < $name: $!";
print {$parfh} "$header\n";
my @types =('none',@covnames,'all');
for (my $i=0;$i<$npar; $i++){
    my $par = $labels[$i];
    for (my $k=0; $k<scalar(@types); $k++){
        my $type = $types[$k];
        my $observed = shift(@{$variance_arrays{$par}->{$type}});
        my $line = '"'.$par.'.'.$type.'",'.sqrt($observed);
        if ($have_uncertainty) {
            my @sorted = (sort {$a <=> $b} @{$variance_arrays{$par}->{$type}});
            my $quantref = quantile(probs => \@probs, numbers=> \@sorted);
            $line .= ','.sqrt($quantref->[0]);
            $line .= ','.sqrt($quantref->[1]);
        } else {
            # NA in quantiles columns if we are in point estimate mode
            $line .= ','.$NA_string.','.$NA_string;
        }

        if ($type eq 'none'){
            $line .= ',' x (1+scalar(@covnames));
        }elsif($type eq 'all'){
            $line .= ','.$coeff_arrays{$par}->{'all'}->[0].','.$coeff_arrays{$par}->{'all'}->[1];
        }else{
            $line .= ','x $k ; #1 or more
            $line .= $coeff_arrays{$par}->{$type}->[0];
            $line .= ','x (scalar(@covnames)-$k) ;
            $line .= ','.$coeff_arrays{$par}->{$type}->[1];
        }

        print {$parfh} "$line\n";
    }
}
close($parfh);



my @templatecode = (
    "library(PsNR)",
    "library(magrittr)",
    "library(methods)",

    "if((file.exists(idfile) || file.exists(frem.ratio)) && ",
    "     file.exists(covdatafile) && file.exists(pardatafile)){" ,
    "    covdata <- read.csv(covdatafile,header = T, as.is = T,check.names = F)",
    "    pardata <- read.csv(pardatafile,header = T, as.is = T,check.names = F)",
    "",
    "    plot_list <- c()",
    "",
    "    if(file.exists(idfile)) {",
    "        frem_id <- read.csv(idfile, header = T, as.is = T,check.names = F)",
    "        indiv_for_param_plots <- ID_ratio(frem_id,covdata,pardata)\$plots",
    "        plot_list <- c(plot_list,indiv_for_param_plots)",
    "    }",
    "",
    "    if(file.exists(frem.ratio)) {",
    "        inTable_frem <- read.csv(frem.ratio,header = T, as.is = T,check.names = F)",
    "        cov_effect_on_param_plots <- parameter_ratio(inTable_frem,covdata,pardata)\$plots",
    "        plot_list <- c(plot_list,cov_effect_on_param_plots)",
    "    }",
    "",
    "    # sd of unexplained variability plots",
    "    if(file.exists(sd.coef.summary)) {",
    "          sd_coef_summary <- read.csv(sd.coef.summary,header = T, as.is = T,check.names = F)",
    "          sd_unexpl_var_plots <- sd_unexpl_var(sd_coef_summary,covdata,pardata)\$plots ",
    "          plot_list <- c(plot_list,sd_unexpl_var_plots)",
    "    }",
    "    if(plot_list!='NULL') {",
    "        ggplot2::ggsave(pdf.filename, gridExtra::marrangeGrob(plot_list, nrow = 1, ncol = 1,top=''), width=11.69, height=8.27)",
    "    }",
    "}",
    );


my $rplot = rplots->new(toolname => 'frem',
                        directory => $main_directory,
                        level => 1,
                        raw_results_file => 'dummy',
                        plotcode => \@templatecode,
                        model => $model);

$rplot->pdf_title('frem plots');
$rplot->add_preamble(code => [
                         "output.format <-'".$options{'output_format'}."'",
                         "covdatafile <- '".$covdatafile."'",
                         "pardatafile <- '".$pardatafile."'",
                         "idfile <- '".$idratiosfile."'",
                         "frem.ratio <- '".$fremratio."'",
                         "frem.condvar <- 'frem_condvar.csv'",
                         "sd.coef.summary <- 'sd_coefficients_summary.csv'",
                     ]);

$rplot->make_plots;
if (-e $main_directory.'/Rplots.pdf'){
    unlink($main_directory.'/Rplots.pdf');
}
