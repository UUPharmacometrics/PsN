#!/usr/bin/perl

# Only for Development
use FindBin qw($Bin);
use lib "$Bin/../lib";

# Don't edit the line below, it must look exactly like this.
# Everything above this line will be replaced #

# Perl includes #
use Config;
use strict;
use Getopt::Long;
# External modules #
use Math::Random;
# PsN includes #
use PsN;
use common_options;
use ui;
use Cwd;
use File::Copy qw/cp mv/;
use File::Glob;
use File::Path 'rmtree';
use tool;
use linear_algebra;
use array qw(quantile);
use MooseX::Params::Validate;
# More PsN dependencies included with require further down

#FIXME these should be options or read from file
my $minimum = 50; #change to 1000 later
my @covnames = (); #from model, first lines in FREM CODE BEGIN BSV_covname =
@covnames=('AGE','WT','NEUY','CLCR','SEX','ACE','NYHA');
my @parnames=('BASE','SLOPE');
my @labels=(@parnames,@covnames);

my @cov_medians = (); #ncov last THETA fix from model
@cov_medians =(65.5773195876,
			   78.4742268041,
			   2761.89690722,
			   67.6082474227,
			   1.24742268041,
			   0.59793814433,
			   2.54639175258);
#numbers from model, very beginning of PK/PRED BSV_x=ETA(n)*number
#npar 1 in beginning
my @cov_rescale = (7.78330886624,
				   15.8482995825,
				   1815.19644532,
				   23.2031592232,
				   0.433756071885,
				   0.492861411691,
				   0.500429368907);




my $cmd_line = $0 . " " . join( " ", @ARGV );

my %options;

my %required_options = ("model:s" => undef,
						'npar:i' => undef,
						'rawres_input:s' => undef,
						'frem_dataset:s' => undef,
	);
my %optional_options = ('offset_rawres:i' => undef,
			'in_filter:s' => undef,
	);

my $res = GetOptions( \%options,
					  @common_options::get_opt_strings,
					  keys(%required_options),
					  keys(%optional_options) );

exit unless $res;




my %help_text;

$help_text{Pre_help_message} = <<'EOF';
Postprocessing for frem
EOF
$help_text{Description} = <<'EOF';
   model plus raw_results from sir
EOF
$help_text{Options} = <<'EOF';

The following options are valid:
EOF
$help_text{Examples} = <<'EOF';
postfrem -model=model_4.mod rawres_input=raw_results_model_4.mod -in_filter=resamples.gt.0
EOF
$help_text{-rawres_input} = <<'EOF';
      -rawres_input=filename

      required. from sir. If have covmatrix from model 4 in frem can run sir
with -samples=1000, resamples=50 and then have no in_filter (just sample from covmatrix).
A bit slow since do MAXEVAL=0 for all samples and not use it for anything, but already implemented
so good enough for now. 
If use final output from sir then make sure use in_filter for resamples.

EOF
$help_text{-frem_dataset} = <<'EOF';
      -frem_dataset=filename

      required. from frem
EOF
$help_text{-offset_rawres} = <<'EOF';
      -offset_rawres=N

      Default is 1, i.e. first line is minimum. Do not set to 0.
EOF
$help_text{-model} = <<'EOF';
    -model
    Required. Model used as sir input.
EOF
$help_text{-npar} = <<'EOF';
    -npar
    Required. Number of parameter etas in last omega block. Then comes covars
EOF
$help_text{-in_filter} = <<'EOF';
      -in_filter=comma-separated list of conditions

    Default not used.
	If full sir run then set to resamples.gt.0, otherwise skip.
EOF

common_options::online_help('postfrem', \%options,\%help_text, \%required_options, \%optional_options);
common_options::setup( \%options, 'postfrem' ); #calls set_globals etc, initiates random sequence

require model;

## Set the automatic renaming of modelfit directory

my $main_directory = tool::get_rundir(create => 1,
				  basename => 'postfrem',
				  modelname => $options{'model'},
				  directory_option => $options{'directory'});

my @outputfiles;


my $eval_string = common_options::model_parameters(\%options);

if( scalar @ARGV > 0 ) {
  die "missing -optionsname?\n";
}
if( not defined $options{'model'})  {
  die "must set -model\n";
}

if( not defined $options{'rawres_input'})  {
  die "must set -rawres_input\n";
}
if( not defined $options{'frem_dataset'})  {
  die "must set -frem_dataset\n";
}
my $npar = $options{'npar'};


my $model = model -> new ( eval( $eval_string ),
			  filename                    => $options{'model'},
			  ignore_missing_output_files => 1 );
    
#TODO read covnames, cov_medians, cov_rescale

sub read_covdata
{
    my %parm = validated_hash(\@_,
							  covnames => { isa => 'ArrayRef', optional => 0 },
							  filename => { isa => 'Str', optional => 0 },
							  dv => { isa => 'Str', default => 'DV' },
	);
	my $covnames = $parm{'covnames'};
	my $filename = $parm{'filename'};
	my $dv = $parm{'dv'};

	my %fremtype_to_cov=();
	my %cov_arrays=();

	for (my $i=0; $i< scalar(@{$covnames}); $i++){
		my $fremtype = ($i+1)*100;
		$fremtype_to_cov{$fremtype}=$covnames->[$i];
		$cov_arrays{$covnames->[$i]} = [];
	}
	
    open my $fh, '<', $filename;
	my $frem_index=-1;
	my $dv_index=-1;
    my $header_row = <$fh>;
	chomp($header_row);
	my @fields = split(',',$header_row);
	for (my $i=0; $i< scalar(@fields); $i++){
		if($fields[$i] eq $dv){
			$dv_index = $i;
		}elsif($fields[$i] eq 'FREMTYPE'){
			$frem_index = $i;
		}
		last if (($frem_index >= 0) and ($dv_index >=0));
	}
	croak("could not find DV and FREMTYPE") unless (($frem_index >= 0) and ($dv_index >=0));
	my $row; 
	while (1) {
		$row = <$fh>;
		last unless (defined $row);
		chomp ($row);
		@fields = split(',',$row);
		if ($fields[$frem_index] > 0){
			my $cov = $fremtype_to_cov{$fields[$frem_index]};
			push(@{$cov_arrays{$cov}},$fields[$dv_index]);
		}
	}
	close $fh;
	for (my $i=1; $i< scalar(@{$covnames}); $i++){
		unless (scalar(@{$cov_arrays{$covnames->[$i]}}) == scalar(@{$cov_arrays{$covnames->[$i-1]}})){
			croak("unequal length $i and $i-1");
		}
		unless (scalar(@{$cov_arrays{$covnames->[$i]}}) > 0){
			croak("legth $i not larger than 0");
		}
	}

	my @perc_5th=();
	my @perc_95th=();
	for (my $i=0; $i< scalar(@{$covnames}); $i++){
		my @sorted = (sort {$a <=> $b} @{$cov_arrays{$covnames->[$i]}}); #sort ascending
		my $quantref = array::quantile(probs => [0.05,0.95], numbers=> \@sorted);
		push(@perc_5th,$quantref->[0]);
		push(@perc_95th,$quantref->[1]);
	}

	return(\@perc_5th,\@perc_95th);
}

my ($cov_5th,$cov_95th) = read_covdata(covnames => \@covnames,
									   filename => $options{'frem_dataset'});


my $sampled_params_arr;
my $href;
my $samples;
my $offset=1;
$offset= $options{'offset_rawres'} if (defined $options{'offset_rawres'});
my @in_filter=();
if ( defined $options{'in_filter'} ){
	#split string, assume comma separated
	foreach my $filt (split(/,/,$options{'in_filter'})){
		if ($filt =~ /.\.(gt|lt|eq)\.\d+\.?\d*/){
			push(@in_filter,$filt);
		}else{
			die "Input filter $filt does not fulfill the format rules.\n";
		}
	}
	if (scalar(@in_filter)<1){
		die "Error: Option in_filter used, but list of conditions could not be parsed.\n";
	}	
}

($sampled_params_arr,$href) = model::get_rawres_params(filename => $options{'rawres_input'},
						   filter => \@in_filter,
						   offset => $offset,
						   model => $model);

if (defined $sampled_params_arr) {
	unless (scalar(@{$sampled_params_arr}) >= $minimum) {
		if (defined $options{'in_filter'}) {
		 croak("Too few sets (lines) of parameter values in\n".
				 "rawres file after filtering. Have ".
		scalar(@{$sampled_params_arr})." but need at least $minimum\n");
		} else {
			croak("Too few sets (lines) of parameter values in\n".
			  "rawres file. Have ".scalar(@{$sampled_params_arr}).
			  " but need at least $minimum plus offset\n");
		}
	}
}else{
   croak("get_rawres_params returned undef");
}


my ($center_params_arr,$href2) = model::get_rawres_params(filename => $options{'rawres_input'},
						   filter => [],
						   offset => 0,
						   model => $model);


chdir($main_directory); #created by tool::get_rundir

#TODO parse out scaling from model
my @sdcorr_array=();

my $omegaindex = scalar(@{$model->problems->[0]->omegas})-1;
my $size = $model->problems->[0]->omegas->[$omegaindex]->size;
my $npar = $options{'npar'};
unless (defined $npar and ($npar < $size)){
	croak("npar $npar is not defined and smaller than size $size");
}

my $index=0;
my $header='sample';
unless (scalar(@labels)==$size){
	croak("size is $size but label count is ".scalar(@labels));
}
for (my $i=0;$i<$size; $i++){
	$header .= ',STDEV.'.$labels[$i];
}
for (my $i=0;$i<$size; $i++){
	for (my $j=0;$j<$i; $j++){
		$header .= ',CORREL.'.$labels[$i].'.'.$labels[$j];
	}
}
for (my $i=0;$i<$npar; $i++){
	for (my $j=$npar;$j<$size; $j++){
		$header .= ',COEFF.par.'.$labels[$i].'.cov.'.$labels[$j];
	}
}
for (my $i=0;$i<$npar; $i++){
	$header .= ',CONDVAR.par.'.$labels[$i].'.given.allcov';
	for (my $j=$npar;$j<$size; $j++){
		$header .= ',CONDVAR.par.'.$labels[$i].'.given.cov.'.$labels[$j];
	}
}
for (my $i=0;$i<$npar; $i++){
	for (my $j=$npar;$j<$size; $j++){
		$header .= ',RATIO.par.'.$labels[$i].'.given.cov5th.'.$labels[$j];
		$header .= ',RATIO.par.'.$labels[$i].'.given.cov95th.'.$labels[$j];
	}
}

open( FILE1, '>pardata.csv' );
print FILE1 'parname'."\n";
for (my $i=0; $i< scalar(@parnames); $i++){
	print FILE1 $parnames[$i]."\n";
}
close FILE1;

open( FILE2, '>covdata.csv' );
print FILE2 'covname,perc5th,median,perc95th'."\n";
for (my $i=0; $i< scalar(@covnames); $i++){
	print FILE2 $covnames[$i].','.$cov_5th->[$i].','.$cov_medians[$i].','.$cov_95th->[$i]."\n";
}
close FILE2;

open( FILE, '>frem_sdcorr.csv' );
print FILE "$header\n";
	
my @rescale = (1) x $npar;
push(@rescale,@cov_rescale);
unless (scalar(@rescale)==$size){
	croak("length rescale is ".scalar(@rescale)." size is $size");
}
for (my $k=0;$k<=scalar(@{$sampled_params_arr}); $k++){
	if ($k==0){
	#center
		$model -> update_inits(from_hash => $center_params_arr->[0]);		
	}else{
		$model -> update_inits(from_hash => $sampled_params_arr->[$k-1]);
	}
	my $varcov = $model->problems->[0]->omegas->[$omegaindex]->get_matrix;
	my $sdcorr=[]; 
	my $error =linear_algebra::covar2sdcorr($varcov,$sdcorr);
	croak("numerr index $k ") unless ($error == 0); 
	
	my $numvec = "$k";
	for (my $i=0;$i<$size; $i++){
		$numvec .= ','.($rescale[$i])*($sdcorr->[$i]->[$i]);   #',STDEV.'$lab;
	}
	for (my $i=0;$i<$size; $i++){
		for (my $j=0;$j<$i; $j++){
			$numvec .= ','.$sdcorr->[$i]->[$j];  #',CORREL.'.$labels[$i].'.'.$labels[$j];
		}
	}
	#covariate coefficients
	for (my $i=0;$i<$npar; $i++){
		for (my $j=$npar;$j<$size; $j++){
			# cov(par,cov)/var(cov) plus rescale
			$numvec .= ','.($varcov->[$i]->[$j])/(($rescale[$j])*($varcov->[$j]->[$j]));
			#',COEFF.par.'.$labels[$i].'.cov.'.$labels[$j];
		}
	}
	#conditional variances 1-1
	for (my $i=0;$i<$npar; $i++){
		my ($error,$result,$coeff) = linear_algebra::conditional_covariance(varcov => $varcov,
																			cov_index_first => $npar,
																			cov_index_last => ($size-1),
																			par_index => $i);
#		print "\n".$result->[0]->[0]."\n";
		if ($error == 0){
#			$header .= ',CONDVAR.par.'.$labels[$i].'.given.allcov;
			$numvec .= ','.$result->[0]->[0];
		}else{
			croak("error conditional_covariance i $i");
		}
		for (my $j=$npar;$j<$size; $j++){
			($error,$result,$coeff) = linear_algebra::conditional_covariance(varcov => $varcov,
																			 cov_index_first => $j,
																			 cov_index_last => $j,
																			 par_index => $i);
#			my $univar = ($varcov->[$i]->[$i])-($varcov->[$i]->[$j])**2/($varcov->[$j]->[$j]);
#			print "\n".$result->[0]->[0]."\n".$univar."\n";
			$numvec .= ','.$result->[0]->[0];
			#rescaling cancels out
			# var(par) -cov(par,cov)Â²/var(cov)
			#			$header .= ',CONDVAR.par.'.$labels[$i].'.given.cov.'.$labels[$j];
		}
		
	}

	
	#predict parameter from covariate
	for (my $i=0;$i<$npar; $i++){
		for (my $j=$npar;$j<$size; $j++){
#			$header .= ',RATIO.par.'.$labels[$i].'.given.cov5th.'.$labels[$j];
			$numvec .= ','.exp(($cov_5th->[($j-$npar)]-$cov_medians[($j-$npar)])*($varcov->[$i]->[$j])/(($rescale[$j])*($varcov->[$j]->[$j])));

#			$header .= ',RATIO.par.'.$labels[$i].'.given.cov95th.'.$labels[$j];
			$numvec .= ','.exp(($cov_95th->[($j-$npar)]-$cov_medians[($j-$npar)])*($varcov->[$i]->[$j])/(($rescale[$j])*($varcov->[$j]->[$j])));
		}
	}

#my ($cov_5th,$cov_95th)
	
	print FILE "$numvec\n";
	push(@sdcorr_array,$numvec);
#	last; 
}
close( FILE );


